## 状态后端

Flink 管理的键控状态是一种分片的键值存储，每个键控状态项的工作副本都保存在负责该键的任务管理器（TaskManager）的本地。操作状态（Operator state）也保存在需要它的机器上。

Flink 管理的状态存储在状态后端中。有两种状态后端的实现可供选择——一种基于 RocksDB，这是一个嵌入式的键值存储，它将工作状态保存在**磁盘**上；另一种是基于**堆**的状态后端，它将工作状态保存在**内存**中，即 **Java 堆**上。
    <img src="article/flink/picture/状态后端.png" alt="图片alt" title="状态后端">

当使用基于堆的状态后端时，状态的访问和更新涉及到在堆上读取和写入对象。但对于保存在 `EmbeddedRocksDBStateBackend` 中的对象，访问和更新涉及到序列化和反序列化，因此成本要高得多。不过，使用 RocksDB 时，你能拥有的状态量仅受限于本地磁盘的大小。还需要注意的是，只有 `EmbeddedRocksDBStateBackend` 能够进行增量快照，这对于拥有大量缓慢变化状态的应用程序来说是一个显著的优势。

这两种状态后端都能够进行**异步快照**，这意味着它们可以在不妨碍持续的流处理的情况下进行快照操作。

### 检查点存储

Flink 定期对每个操作符中的所有状态进行持久化快照，并将这些快照复制到更持久的地方，例如分布式文件系统。在发生故障时，Flink 可以恢复应用程序的完整状态，并像什么都没发生一样继续处理。

这些快照存储的位置是通过作业的检查点存储来定义的。有两种检查点存储的实现可供选择——一种将状态快照持久化到**分布式文件系统**，另一种使用 **JobManager 的堆**。
    <img src="article/flink/picture/检查点存储.png" alt="图片alt" title="检查点">

- **FileSystemCheckpointStorage**
  - **描述**：将检查点数据存储在分布式文件系统中，如 HDFS、S3 等。
  - **优点**：
    - **支持非常大的状态大小**：可以处理非常大的状态，不受单个机器内存限制。
    - **高度持久**：数据存储在分布式文件系统中，具有高可用性和持久性。
    - **推荐用于生产部署**：适合生产环境，因为它的可靠性和可扩展性。
  - **适用场景**：生产环境中的大规模流处理应用。
- **JobManagerCheckpointStorage**
  - **描述**：将检查点数据存储在 JobManager 的 JVM 堆中。
  - **优点**：
    - **适用于测试和小状态的实验**：适合在本地进行测试和实验，特别是当状态大小较小时。
  - **适用场景**：开发和测试环境，特别是当状态大小较小且不需要高持久性时。

### 状态快照

- 快照（Snapshot）一个通用术语，指的是 Flink 作业状态的一个全局、一致的图像。一个快照包括每个数据源的指针（例如，文件或 Kafka 分区中的偏移量），以及每个状态化操作符的状态副本，这些状态是处理所有到达这些位置的事件的结果。
- 检查点（Checkpoint）Flink 自动进行的快照，目的是为了能够从故障中恢复。检查点可以是增量的，并且优化为能够快速恢复。
- 外部化检查点（Externalized Checkpoint）通常检查点不打算由用户操作。Flink 在作业运行时仅保留最近的 n 个检查点（n 可配置），并在作业取消时删除它们。但你可以配置它们以保留，这样你就可以手动从中恢复。
- 保存点（Savepoint）由用户（或 API 调用）手动触发的快照，用于某些运维目的，例如有状态的重新部署/升级/重新缩放操作。保存点总是完整的，并且优化为具有运维灵活性。

### 状态快照是如何工作的

Flink 使用 Chandy-Lamport 算法的一个变体，称为**异步屏障快照**。

当**任务管理器（TaskManager）**被**检查点协调器**（作业管理器的一部分）指示开始一个**检查点**时，它会让所有**数据源**记录它们的偏移量，并在它们的流中插入**编号的检查点屏障**。这些屏障流经作业图，指示每个**检查点**之前和之后的流的部分
    <img src="article/flink/picture/快照工作流.png" alt="图片alt" title="快照工作流">

这张图片展示了 Flink 中异步屏障快照（asynchronous barrier snapshotting）的工作机制，这是 Flink 用来进行状态快照的一种方法。图片中的数据流被分为几个部分，每个部分对应一个检查点（checkpoint）。

1. **数据流（Data Stream）**：图中的箭头表示数据流的方向，从左到右流动。
2. **检查点屏障（Checkpoint Barriers）**：图中的垂直线表示检查点屏障。这些屏障被插入到数据流中，用于标记检查点的开始和结束。每个屏障都有一个编号，例如图中的 "checkpoint barrier n" 和 "checkpoint barrier n-1"。
3. **检查点分区（Parts of Checkpoints）**：
   - **检查点 n+1 的部分**：在最新的检查点屏障 "checkpoint barrier n" 之前的新记录，这些记录将属于下一个检查点 n+1。
   - **检查点 n 的部分**：在 "checkpoint barrier n" 和前一个屏障 "checkpoint barrier n-1" 之间的记录，这些记录属于当前检查点 n。
   - **检查点 n-1 的部分**：在 "checkpoint barrier n-1" 之前的旧记录，这些记录属于前一个检查点 n-1。
4. **流记录（Stream Record/Event）**：图中右侧的黄色矩形表示一个流记录或事件，它位于检查点 n 的部分。
5. **新记录和旧记录**：图中用 "newer records" 和 "older records" 标注了数据流中的新旧记录，新记录位于检查点屏障的左侧，而旧记录位于右侧。

这种机制允许 Flink 在不停止数据处理的情况下，对整个应用的状态进行一致性的快照。当故障发生时，Flink 可以使用这些快照来恢复状态并继续处理。
    <img src="article/flink/picture/屏障对齐机制.png" alt="图片alt" title="屏障对齐机制">

### 精确一次保证

在流处理应用程序中出现问题时，可能会丢失结果，或者出现重复的结果。使用 Flink 时，根据你为应用程序所做的选择以及运行它的集群，可能会出现这些结果中的任何一种：

- Flink 不努力从故障中恢复（最多一次）
- 没有丢失，但可能会经历重复的结果（至少一次）
- 没有丢失或重复（精确一次）

### 端到端精确一次 

为了实现端到端的精确一次，使得每个来自源的事件恰好一次影响接收器，以下条件必须为真：

- 你的源必须是可重放的，并且
- 你的接收器必须是事务性的（或幂等的）

### 注意

鉴于 Flink 通过倒带和重放源数据流来从故障中恢复，当理想情况被描述为精确一次时，这并不意味着每个事件都将被精确处理一次。相反，这意味着每个事件将恰好一次影响 Flink 管理的状态。

屏障对齐仅在提供精确一次保证时需要。如果你不需要这个，你可以通过配置 Flink 使用 **CheckpointingMode.AT_LEAST_ONCE **来获得一些性能提升，这将禁用屏障对齐的效果。

### 
