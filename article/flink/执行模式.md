**BATCH 和 STREAMING 执行模式的任务调度和网络 shuffle 工作方式不同。这主要是因为在 BATCH 执行模式下我们知道输入数据是有界的**，这允许 Flink 使用更高效的数据结构和算法。

### STREAMING 执行模式

在 STREAMING 执行模式下，所有任务都需要一直在线/运行。这使得 Flink 能够立即将新记录通过整个管道进行处理，这是我们进行连续且低延迟流处理所需要的。这也意味着分配给作业的 TaskManagers 需要有足够的资源来同时运行所有任务。

网络 shuffle 是流水线式的，意味着记录会立即发送到下游任务，在网络层会有一些缓冲。再次强调，这是必需的，因为在处理连续数据流时，在任务（或任务管道）之间没有自然的时间点可以对数据进行物化。这与 BATCH 执行模式形成对比，在 BATCH 执行模式下，可以物化中间结果，如下文所述。



### BATCH 执行模式

在 BATCH 执行模式下，作业的任务可以被划分为可以依次执行的阶段。我们可以这样做，因为输入是有界的，Flink 因此可以在进入下一阶段之前完全处理管道的一个阶段。在上面的示例中，作业将有三个阶段，分别对应于由 shuffle 障碍分隔的三个任务。

与上面为 STREAMING 模式解释的立即向下游任务发送记录不同，分阶段处理要求 Flink 将任务的中间结果物化到某种非临时存储中，这允许下游任务在上游任务已经离线后读取它们。这将增加处理的延迟，但具有其他有趣的属性。首先，当发生故障时，这允许 Flink 回溯到最新的可用结果，而不是重新启动整个作业。另一个副作用是，BATCH 作业可以在更少的资源（就 TaskManagers 的可用插槽数量而言）上执行，因为系统可以依次一个接一个地执行任务。

**TaskManagers 会至少保留中间结果，直到下游任务已经消费它们为止。（从技术上讲，它们将被保留，直到消费的流水线区域产生它们的输出。）在那之后，只要空间允许，它们将被保留，以便在故障情况下回溯到早期结果。**

### 状态后端/状态

在 STREAMING 模式下，**Flink 使用 StateBackend 来控制状态的存储方式以及检查点的工作方式**。

在 BATCH 模式下，配置的状态后端将被忽略。相反，将按照键对键控操作的输入进行分组（使用排序），然后依次处理一个键的所有记录。这允许同时只保留一个键的状态。当移动到下一个键时，给定键的状态将被丢弃。

### 处理顺序

在操作符或用户定义函数（UDFs）中处理记录的顺序在 BATCH 和 STREAMING 执行之间可能有所不同。

在 STREAMING 模式下，用户定义的函数不应对接收记录的顺序做出任何假设。数据一旦到达就会被处理。

在 BATCH 执行模式下，Flink 在某些操作中保证顺序。排序可能是特定任务调度、网络 shuffle 和状态后端（见上文）的副作用，或者是系统的有意识选择。

我们可以区分三种类型的输入：

广播输入：来自广播流的输入（另见广播状态） 

常规输入：既不是广播也不是键控的输入 

键控输入：来自 KeyedStream 的输入 消费多种输入类型的函数或操作符将按以下顺序处理它们：

**先处理广播输入 其次处理常规输入 最后处理键控输入 **对于从多个常规或广播输入消费的函数（例如 CoProcessFunction），Flink 有权以任意顺序处理该类型的任何输入的数据。

对于从多个键控输入消费的函数（例如 KeyedCoProcessFunction），Flink 会在移动到下一个键之前，先处理来自所有键控输入的单个键的所有记录。



### 事件时间/水位线

在支持事件时间方面，Flink 的流式运行时基于一个悲观的假设，即事件可能会乱序到达，也就是说，时间戳为 t 的事件可能会在时间戳为 t + 1 的事件之后到达。因为这个原因，系统永远无法确定未来是否还会有时间戳为 t < T 的元素到达。为了在减轻这种乱序对最终结果的影响的同时使系统具有实用性，在 STREAMING 模式下，Flink 使用一种称为水位线的启发式方法。带有时间戳 T 的水位线表示不会跟随时间戳为 t < T 的元素。

在 BATCH 模式下，输入数据集是事先已知的，因此不需要这种启发式方法，因为至少可以按时间戳对元素进行排序，以便它们按时间顺序被处理。对于熟悉流处理的读者来说，在 BATCH 模式下，我们可以假设“完美的水位线”。

鉴于上述情况，在 BATCH 模式下，我们只需要在每个键的输入结束时（如果输入流是键控的）或在输入结束时（如果输入流不是键控的）有一个 MAX_WATERMARK。根据这种方案，所有注册的计时器将在时间结束时触发，用户定义的 WatermarkAssigners 或 WatermarkGenerators 将被忽略。不过，指定 WatermarkStrategy 仍然很重要，因为它的 TimestampAssigner 仍将用于为记录分配时间戳。



### 处理时间

处理时间是记录被处理的机器上的时钟时间，在记录被处理的特定实例上。根据这个定义，我们可以看到，基于处理时间的计算结果是不可重现的。这是因为同一条记录被处理两次将会有两个不同的时间戳。

尽管如此，在 STREAMING 模式下使用处理时间可能很有用。原因在于流处理管道通常实时摄取其无界输入，因此事件时间和处理时间之间存在相关性。此外，由于上述原因，在 STREAMING 模式下，事件时间中的1小时通常可以接近处理时间或时钟时间中的1小时。因此，使用处理时间可以用于早期（不完整的）触发，以提供有关预期结果的提示。

在批处理世界中，这种相关性是不存在的，因为输入数据集是静态的且事先已知。鉴于此，在 BATCH 模式下，我们允许用户请求当前的处理时间并注册处理时间计时器，但是，和事件时间的情况一样，所有计时器都将在输入结束时触发。

从概念上讲，我们可以想象在作业执行期间处理时间不会前进，而是在整个输入被处理时快进到时间的尽头。



### 故障恢复

在 STREAMING 执行模式下，Flink 使用检查点进行故障恢复。查看检查点文档以获取有关此内容的实用文档以及如何配置它的信息。还有一个关于通过状态快照实现容错的入门部分，该部分在更高层次上解释了相关概念。

检查点用于故障恢复的一个特点是，Flink 会在故障情况下从检查点重新启动所有运行中的任务。这可能比我们在 BATCH 模式下必须做的（如下文解释）成本更高，这是如果你的作业允许，你应该使用 BATCH 执行模式的原因之一。

在**BATCH 执行模式下，Flink 将尝试回溯到仍然可用中间结果的先前处理阶段。可能只有失败的任务（或图中的它们的前驱任务）需要重新启动，这与从检查点重新启动所有任务相比，可以提高处理效率并缩短作业的整体处理时间**。

### 重要注意事项

与经典的 STREAMING 执行模式相比，在 BATCH 模式下，有些事情可能不会按预期工作。一些功能将略有不同，而其他一些则不受支持。

BATCH 模式下的行为变化：

像 reduce（）或 sum（）这样的“滚动”操作在 STREAMING 模式下为每个到达的新记录发出增量更新。在 BATCH 模式下，这些操作不是“滚动”的。它们只发出最终结果。 BATCH 模式下不受支持：

检查点以及任何依赖于检查点的操作都不起作用。 应谨慎实现自定义操作符，否则它们可能会表现不正常。



### 检查点

如上所述，批处理程序的故障恢复不使用检查点。

重要的是要记住，因为没有检查点，某些功能（如 CheckpointListener）以及因此 Kafka 的 EXACTLY_ONCE 模式或文件接收器的 OnCheckpointRollingPolicy 等将不起作用。如果你需要一个在 BATCH 模式下可以工作的事务性接收器，请确保它使用 FLIP - 143 中提出的统一接收器 API。

你仍然可以使用所有的状态原语，只是用于故障恢复的机制将不同。

编写自定义操作符# 注意：自定义操作符是 Apache Flink 的高级用法模式。对于大多数用例，请考虑使用（键控）处理函数。 在编写自定义操作符时，重要的是要记住 BATCH 执行模式所做的假设。否则，对于 STREAMING 模式可以正常工作的操作符在 BATCH 模式下可能会产生错误的结果。操作符永远不会限定于特定的键，这意味着它们会看到 Flink 尝试利用的 BATCH 处理的一些属性。

首先，你不应在操作符内缓存最后看到的水位线。在 BATCH 模式下，我们按键处理记录。因此，水位线将在每个键之间从 MAX_VALUE 切换到 MIN_VALUE。你不应假设水位线在操作符中总是递增的。由于相同的原因，计时器将首先按键顺序触发，然后在每个键内按时间戳顺序触发。此外，手动更改键的操作不受支持。

