### Flink 集群的组成

Flink 运行时由两种类型的进程组成：一个 JobManager 和一个或多个 TaskManagers。
<img src="article/flink/picture/Flink完整架构.png" alt="图片alt" title="Flink完整架构">

**客户端不是运行时和程序执行的一部分**，但它用于**准备和发送数据流到 JobManager**。之后，客户端可以断开连接（分离模式），或者**保持连接以接收进度报告**（附加模式）。客户端可以作为触发执行的 Java/Scala 程序的一部分运行，或者在命令行进程 ./bin/flink run .... 中运行

JobManager 和 TaskManagers 可以通过多种方式启动：**作为独立集群直接在机器上启动**，**在容器中启动**，或由**资源框架（如 YARN）管理**。TaskManagers 连接到 JobManagers，宣布自己可用，并被分配工作。

### JobManager 

JobManager 有多个与协调 Flink 应用程序分布式执行相关的职责：它决定何时**调度下一个任务（或一组任务）**，对已完成的任务或执行失败做出反应，**协调检查点**，并在**发生故障时协调恢复**等。这个过程由三个不同的组件组成：

资源管理器（ResourceManager）

资源管理器负责 Flink 集群中的资源分配/释放和供应——它管理任务槽，这是 Flink 集群中资源调度的单位。Flink 为不同的环境和资源提供者（如 YARN、Kubernetes 和独立部署）实现了多个资源管理器。在独立设置中，资源管理器只能分配可用 TaskManagers 的槽，不能自行启动新的 TaskManagers。

调度器（Dispatcher）

调度器提供一个 REST 接口来提交 Flink 应用程序以供执行，并为每个提交的作业启动一个新的 JobMaster。它还运行 Flink WebUI，以提供有关作业执行的信息。

作业管理器（JobMaster）

作业管理器负责管理**单个 JobGraph 的执行**。多个作业可以同时在 Flink 集群中运行，每个作业都有自己的作业管理器。

JobManager 总是至少有一个。高可用性设置可能具有多个 JobManagers，其中一个始终是领导者，其他是备用（见高可用性（HA））。

### TaskManagers 

**TaskManagers（也称为工作器）执行数据流的任务，并缓冲和交换数据流。**

TaskManagers 必须始终至少有一个。**TaskManager 中资源调度的最小单位是任务槽**。TaskManager 中的任务槽数量表示可以同时处理的任务数量。请注意，**多个操作符可能在任务槽中**执行。

### 任务和操作符链

为了**分布式执行，Flink 将操作符子任务链接在一起形成任务**。每个任务由一个线程执行。将操作符链接在一起形成任务是一种有用的优化：**它减少了线程间交接和缓冲的开销，提高了整体吞吐量，同时降低了延迟**。链式行为可以配置；

### 任务槽和资源

每个工作器（TaskManager）是一个 JVM 进程，可以在单独的线程中执行一个或多个子任务。为了控制 TaskManager 接受多少任务，它有所谓的任务槽（至少一个）。

每个任务槽代表 TaskManager 的固定资源子集。例如，具有三个槽的 TaskManager 将把其管理的内存的 1/3 专用于每个槽。**资源分槽意味着子任务不会与其他作业的子任务竞争管理内存**，而是有一定数量的保留管理内存。请注意，这里没有进行 CPU 隔离；当前槽仅分离任务的管理内存。

通过调整任务槽的数量，用户可以定义子任务彼此之间的隔离程度。每个 TaskManager 有一个槽意味着每个任务组在单独的 JVM 中运行（可以例如在单独的容器中启动）。**拥有多个槽意味着更多的子任务共享同一个 JVM**。同一个 JVM 中的任务**共享 TCP 连接（通过多路复用）和心跳消息。它们还可能共享数据集和数据结构，从而减少每个任务的开销**。



默认情况下，Flink 允许子任务共享槽，即使它们是不同任务的子任务，只要它们来自**同一个作业**。结果是，一个槽可以容纳整个作业的流水线。**允许这种槽共享有两个主要好处**：

A. **Flink 集群需要的槽数量正好等于作业中使用的最高并行度。**无需计算程序中总共包含多少个任务（具有不同的并行度）。

B. **更容易获得更好的资源利用率。**如果没有槽共享，非密集型的源/映射（source/map()）子任务会占用与资源密集型的窗口（window）子任务一样多的资源。有了槽共享，将我们示例中的基础并行度从两个增加到六个，可以充分利用槽资源，同时确保重型子任务在 TaskManagers 之间公平分配。

### Flink 应用程序执行 

Flink 应用程序是从其 main() 方法生成一个或多个 Flink 作业的任何用户程序。这些作业的执行可以发生在**本地 JVM（LocalEnvironment）上**，也可以发生在具有多台机器的远程集群设置（RemoteEnvironment）上。对于每个程序，ExecutionEnvironment 提供了**控制作业执行的方法（例如设置并行度）以及与外部世界交互的方法**。

Flink 应用程序的作业可以提交到**长时间运行的 Flink 会话集群**、**专用的 Flink 作业集群（已弃用）**或 **Flink 应用程序集群**。这些选项之间的差异主要与**集群的生命周期和资源隔离**保证有关。

### Flink 应用程序集群——Flink Application Cluster

集群生命周期：Flink 应用程序集群是一个专用的 Flink 集群，仅执行来自一个 Flink 应用程序的作业，其中 main() 方法在**集群上而不是客户端上运行**。作业提交是一个单步过程：您不需要先启动 Flink 集群，然后将**作业提交到现有集群会话**；相反，您将应用程序逻辑和依赖项打包到可执行的作业 JAR 中，集群入口点（ApplicationClusterEntryPoint）负责调用 main() 方法以提取 JobGraph。这允许您像在 Kubernetes 上部署任何其他应用程序一样部署 Flink 应用程序。**因此，Flink 应用程序集群的生命周期因此与 Flink 应用程序的生命周期绑定**。

资源隔离：在 Flink 应用程序集群中，ResourceManager 和 Dispatcher 作用于单个 Flink 应用程序，这比 Flink 会话集群提供了更好的关注点分离。



### Flink 会话集群-Flink Session Cluster

集群生命周期：在 Flink 会话集群中，客户端连接到一个预先存在、长时间运行的集群，该集群可以接受多个作业提交。即使在所有作业完成后，集群（和 JobManager）也将保持运行，直到会话被手动停止。**因此，Flink 会话集群的生命周期因此不与任何 Flink 作业的生命周期绑定**。

资源隔离：TaskManager 槽由 ResourceManager 在作业提交时分配，并在作业完成后释放。由于所有作业都共享同一个集群，**因此在提交作业阶段会有一些集群资源（如网络带宽）的竞争**。这种共享设置的一个限制是，如果一个 TaskManager 崩溃，则所有在此 **TaskManager 上运行任务的作业都将失败**；同样，如果 JobManager 上发生某些致命错误，它将影响集群中运行的所有作业。

其他考虑因素：拥有预先存在的集群可以节省大量申请资源和启动 TaskManagers 的时间。这在作业执行时间非常短，高启动时间会对端到端用户体验产生负面影响的场景中非常重要——就像交互式分析短查询一样，希望作业能够快速使用现有资源进行计算。

以前，Flink 会话集群也被称为 Flink 集群的会话模式。

### Flink 作业集群（已弃用）-Flink Job Cluster (deprecated) 

按作业模式仅由 YARN 支持，并在 Flink 1.15 中已弃用。它将在 FLINK-26000 中被删除。请考虑使用应用程序模式在 YARN 上按作业启动专用集群。

集群生命周期：在 Flink 作业集群中，可用的集群管理器（如 YARN）用于为每个提交的作业启动集群，并且此集群仅对该作业可用。在这里，客户端首先从集群管理器请求资源以启动 JobManager，并将作业提交到此进程内运行的 Dispatcher。然后根据作业的资源需求延迟分配 TaskManagers。一旦作业完成，Flink 作业集群就会被拆除。

资源隔离：JobManager 中的致命错误只会影响该 Flink 作业集群中运行的一个作业。

其他考虑因素：**由于 ResourceManager 必须申请并等待外部资源管理组件启动 TaskManager 进程并分配资源**，因此 **Flink 作业集群更适合于长时间运行、具有高稳定性要求且对较长启动时间不敏感的大型作业。**

以前，Flink 作业集群也被称为 Flink 集群的作业（或按作业）模式；**Flink Cluster `job (or per-job) mode`。**

 Flink 作业集群仅在 YARN 上受支持。
